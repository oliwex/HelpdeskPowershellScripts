###########################VARIABLES###################################
$monitoredOU="KOMPUTERY"



########################################################################

#Current State
$gpoLast=Get-ADOrganizationalUnit -Filter {name -eq $monitoredOU} | Select-Object -ExpandProperty distinguishedname | Get-GPInheritance | Select-Object -ExpandProperty gpolinks | ForEach-Object {Get-GPO -Guid $_.gpoid} | Select-Object DisplayName,Id,CreationTime,ModificationTime

while($true)
{
    Read-Host "Change GPO: "
    
    #Get data after change
    $gpoCurrent=Get-ADOrganizationalUnit -Filter {name -eq "KOMPUTERY"} | Select-Object -ExpandProperty distinguishedname | Get-GPInheritance | Select-Object -ExpandProperty gpolinks | ForEach-Object {Get-GPO -Guid $_.gpoid} | Select-Object DisplayName,Id,CreationTime,ModificationTime
    
    #Testing variables
    $testLast=[string]::IsNullOrEmpty($gpoLast)
    $testCurrent=[string]::IsNullOrEmpty($gpoCurrent)

    if ((-not($testLast)) -and (-not($testCurrent))) # 11
    {
        $time=Compare-Object -ReferenceObject $gpoLast.ModificationTime -DifferenceObject $gpoCurrent.ModificationTime
        $testTime=[string]::IsNullOrEmpty($time)
        
        if (-not($testTime))
        {
            "Oba są pełne ale się różnią datą modyfikacji-invoke"
        }
        else
        {
            "Oba się pełne i są takie same"
        }

    }
    if ((-not($testLast)) -and $testCurrent) # 10
    {
        "zmienila sie licznosc -invoke"
    }
    if ($testLast -and (-not($testCurrent))) # 01
    {
        "zmieniła się licznosc - invoke"
    }
    if ($testLast -and $testCurrent) # 00
    {
        "Obie są puste - bez zmian"
    }

    $gpoLast=$gpoCurrent 
    Start-Sleep -Seconds 5
}





###########################################################################3
function Get-ComputerReport 
{
##requires SysInfo
    $computerReport = [ordered]@{
        "Disk"            = Get-DiskDrive | Select-Object Caption, @{Name = "Size"; Expression = { [Math]::Round(($_.Size / 1GB), 2), "GB" -join " " } }
        "Processor"       = Get-Processor | Select-Object Name, @{Name = "TDP"; Expression = { $_.MaxClockSpeed } }
        "Memory"          = Get-PhysicalMemoryArray | Select-Object @{Name = "RAM"; Expression = { ($_.MaxCapacity / 1MB), "GB" -join " " } }
        "VideoController" = Get-VideoController | Where-Object { $_.DeviceId -eq "VideoController1" } | Select-Object Name, @{Name = "RAM"; Expression = { ($_.AdapterRam / 1GB), "GB" -join " " } }
    }

    return $computerReport
}

function Get-QuotaReport 
{
##requires Carbon
$unitList ="KB", "MB", "GB", "TB", "PB", "EB"
$path="HKLM:\Software\Policies\Microsoft\Windows NT"

$pathExist=Test-RegistryKeyValue -Path $path -Name "DiskQuota"

$path=Join-Path -Path $path -ChildPath "DiskQuota"

if ($pathExist)
{
    $quotaReport = Get-ItemProperty -Path $path | Select-Object Enable, Enforce, Limit, LimitUnits, Threshold, ThresholdUnits
    $quotaReport = [ordered]@{
        "enable"         = $quotaReport.Enable
        "enforce"        = $quotaReport.Enforce 
        "limit"          = $quotaReport.Limit 
        "LimitUnits"     = $unitList[$quotaReport.LimitUnits - 1] 
        "Threshold"      = $quotaReport.Threshold
        "ThresholdUnits" = $unitList[$quotaReport.ThresholdUnits - 1] 
    }
}
else 
{
    $quotaReport = [ordered]@{
        "enable"         ="UNSET" 
        "enforce"        ="UNSET" 
        "limit"          ="UNSET" 
        "LimitUnits"     ="UNSET" 
        "Threshold"      ="UNSET"
        "ThresholdUnits" = "UNSET"
    }
}
return $quotaReport
}

$softwareList = [ordered]@{
    "7-Zip"             = "*Igor Pavlov*" 
    "Adobe"             = "*Adobe*" 
    "Notepad++"         = "*Notepad++ Team*" 
    "Microsoft Edge"    = "*Microsoft*" 
    "Java 8"            = "*Oracle*" 
}

function Get-SoftwareReport
{
    [CmdletBinding()]
    Param(
    [Parameter(Mandatory=$true,HelpMessage="SoftwareList",Position=0)]
    $softwareList
    )

##requires Carbon
    $programList = [ordered]@{}

    $32bitPath = "HKLM:\SOFTWARE\Wow6432node\Microsoft\Windows\CurrentVersion\Uninstall" 
    $64bitPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"

    foreach ($programName in $softwareList.Keys)
    {
        $32bitPathProgram=Join-Path -Path $32bitPath -ChildPath $programName
        $64bitPathProgram=Join-Path -Path $64bitPath -ChildPath $programName

        $32bitTest=Test-RegistryKeyValue -Path $32bitPathProgram -Name DisplayName
        $64bitTest=Test-RegistryKeyValue -Path $64bitPathProgram -Name DisplayName
    

        if ($64bitTest) #Test 64bit
        {
            $programInfo=Get-ChildItem $64bitPath | Get-ItemProperty | Select-Object DisplayName, Version, InstallDate, Publisher, InstallLocation| Where-Object { ($_.DisplayName -like "*$programName*") -and ($_.Publisher -like "*$($softwareList[$programName])*") }
            $programList.Add($programName,$programInfo)
        }
        elseif ($32bitTest) #Test 32bit
        {
            $programInfo=Get-ChildItem $32bitPath | Get-ItemProperty | Select-Object DisplayName, Version, InstallDate, Publisher, InstallLocation | Where-Object { ($_.DisplayName -like "*$programName*") -and ($_.Publisher -like "*$($softwareList[$programName])*") }
            $programList.Add($programName,$programInfo)
        }
        else
        {
            $programList.Add($programName,"UNSET")
        }
    }

    return $programList


}


function Get-FilesReport
{
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$true,HelpMessage="UserName.",Position=0)]
    [String]$userName,
    [Parameter(Mandatory=$true,HelpMessage="GroupName",Position=1)]
    [String]$groupName,
    [Parameter(Mandatory=$true,HelpMessage="Department",Position=2)]
    [String]$departmentName
)

##requires NTFSSecurity

$filesReport = [ordered]@{
}

if (Test-Path -Path $departmentPath -PathType Container)
{
    $userAccessDepartmentFolder=Get-Item -Path $departmentPath | Get-NTFSEffectiveAccess -Account $userName | select Account, AccessRights, FullName
    $filesReport.Add("DepartmentFolderUserAccess", $userAccessDepartmentFolder)


    $groupAccessDepartmentFolder=Get-Item -Path $departmentPath | Get-NTFSEffectiveAccess -Account $groupName |select Account, AccessRights, FullName
    $filesReport.Add("DepartmentFolderGroupAccess",$groupAccessDepartmentFolder)
    
    $userPath=Join-Path -Path $departmentPath -ChildPath $userName.Substring($userName.IndexOf("\")+1)
    if (Test-Path -Path $userPath -PathType Container)
    {
        $userAccessUserFolder=Get-Item -Path $userPath | Get-NTFSEffectiveAccess -Account $userName | select Account, AccessRights, FullName
        $filesReport.Add("UserFolderUserAccess",$userAccessUserFolder)

        $groupAccessUserfolder=Get-Item -Path $userPath | Get-NTFSEffectiveAccess -Account $groupName |select Account, AccessRights, FullName
        $filesReport.Add("UserFolderGroupAccess",$groupAccessUserfolder)
    }
    else
    {
        $filesReport.Add("UserFolderUserAccess","UNSET")
        $filesReport.Add("UserFolderGroupAccess","UNSET")
    }
}
else
{
    $filesReport.Add("DepartmentFolderUserAccess", "UNSET")
    $filesReport.Add("DepartmentFolderGroupAccess","UNSET")
    $filesReport.Add("UserFolderUserAccess","UNSET")
    $filesReport.Add("UserFolderGroupAccess","UNSET")
}



return $filesReport

}



function Get-NetworkInformation
{

    $deviceId=Get-NetAdapter -Physical | Where-Object {$_.Status -eq "Up"} | Select -ExpandProperty DeviceId
    $DHCPStatus=Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces\$id" | Select-Object -ExpandProperty EnableDHCP

    if ($DHCPStatus -eq 1)
    {
        #Przypisane DHCP
        $networkInfo=Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces\$deviceId" | Select-Object @{Name="IPAddress";Expression={$_.DhcpIpAddress}},@{Name="SubnetMask";Expression={$_.DHCPSubnetMask}},@{Name="DefaultGateway";Expression={$_.DHCPDefaultGateway}},@{Name="NameServer";Expression={$_.DHCPNameServer}},@{Name="DHCPServer";Expression={$_.DHCPServer}}
    }
    else
    {
        #Przypisane Manualnie
        $networkInfo=Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces\$deviceId" | Select-Object  @{Name="IPAddress";Expression={$_.IPAddress}},@{Name="SubnetMask";Expression={$_.SubnetMask}},@{Name="DefaultGateway";Expression={$_.DefaultGateway}},@{Name="NameServer";Expression={$_.NameServer}},@{Name="DHCPServer";Expression={"UNSET"}}
    }

    $network = [ordered]@{
            IPAddress        = $networkInfo.IPAddress
            SubnetMask       = $networkInfo.SubnetMask
            DefaultGateway   = $networkInfo.DefaultGateway
            NameServer       = $networkInfo.NameServer
            DHCPServer       = $networkInfo.DHCPServer
            }

    return $network
}
function Get-PrintReport
{
    $printer=Get-Printer | Where-Object {(($_.PortName -like "*USB*") -or ($_.PortName -like "192.168.*.*")) -and ($_.DeviceType -eq "Print")} | Select Name,Type,DriverName,PortName,Shared,Published
    $printReport = [ordered]@{}
    foreach ($print in $printer)
    {
        $printReport.Add($print.Name,$print)
    }
    return $printReport
}


function Get-ServiceReport 
{
    $services = Get-Service wuauserv, AppIDSvc, WinDefend, mpssvc, W32Time | Select-Object Name, Status, StartType 
    $serviceReport = [ordered]@{
        "AppIDSvc"  = $services[0]
        "mpssvc"    = $services[1] 
        "W32Time"   = $services[2]
        "WinDefend" = $services[3]
        "wuauserv"  = $services[4]  
    }
    return $serviceReport
}

function Get-FirewallReport 
{
    $firewallReportArray=(Get-NetFirewallProfile -PolicyStore ActiveStore | Select-Object Name, Enabled, @{label = "LogFilePath"; expression = { $_.LogFileName } }, @{label = "LogSize"; expression = { $_.LogMaxSizeKilobytes } })
    $firewallReport = [ordered]@{
        Domain  = $firewallReportArray[0]
        Private = $firewallReportArray[1]
        Public  = $firewallReportArray[2]
    }
    return $firewallReport
}


function Get-DefenderReport
{

    $paths="HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender\Signature Updates","HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender"

    $defenderReport = [ordered]@{
        "Windows Defender Status"           = $null
        "Potentially Unwanted Apps"         = $null
        "Removable Drives Scanning"         = $null
        "Scan All Files and Attachments"    = $null
        "Security Update days"              = $null
        "Spyware Update Days"               = $null
    }
    
    $status=Get-ItemProperty -Path $paths[1] | Select @{Name="Windows Defender";Expression={$_.DisableAntiSpyware}}
    if (-not ($status -eq 1))
    {
        $defenderReport["Windows Defender Status"]="SET"
    }
    else
    {
        $defenderReport["Windows Defender Status"]="UNSET"
    }

    $status=Get-MpPreference | Select-Object PUAProtection,DisableRemovableDriveScanning,DisableIOAVProtection  #b,c,d 
    if ($status.PUAProtection -eq 0)
    {
        $defenderReport["Potentially Unwanted Apps"]="UNSET"
    }
    elseif ($status.PUAProtection -eq 1)
    {
        $defenderReport["Potentially Unwanted Apps"]="BLOCK"
    }
    elseif ($status.PUAProtection -eq 2)
    {
        $defenderReport["Potentially Unwanted Apps"]="AUDIT"
    }

    if (-not ($status.DisableRemovableDriveScanning -eq "True"))
    {
        $defenderReport["Removable Drives Scanning"]="SET"
    }
    else
    {
        $defenderReport["Removable Drives Scanning"]="UNSET"
    }

    if (-not ($status.DisableIOAVProtection -eq "True"))
    {
        $defenderReport["Scan All Files and Attachments"]="SET"
    }
    else
    {
        $defenderReport["Scan All Files and Attachments"]="UNSET"
    }


    $test=Test-RegistryKeyValue -Path $paths[0] -Name "AVSignatureDue"
    if ($test)
    {
        $defenderElement=Get-ItemProperty -Path $paths[0] | Select-Object @{Name="Security updates days";expression={$_.AVSignatureDue}},@{Name="Spyware update days";expression={$_.ASSignatureDue}}
        $defenderReport["Security Update days"]=$defenderElement."Security updates days"
        $defenderReport["Spyware Update Days"]=$defenderElement."Spyware Update Days"
    }
    else
    {
        $defenderReport["Security Update days"]="UNSET"
        $defenderReport["Spyware Update Days"]="UNSET"
    }

    return $defenderReport
}



function New-LogReport 
{
    $applicationLogResult = Get-WinEvent -ListLog Application | Select-Object LogName, @{label = "MaximumSizeInBytes"; expression = { $_.MaximumSizeInBytes / 1024 } }, LogMode, @{label = "Retention"; expression = { Get-ItemProperty -Path HKLM:\SOFTWARE\Policies\Microsoft\Windows\EventLog\Application | Select -ExpandProperty Retention } }
    $setupLogResult = Get-WinEvent -ListLog Setup | Select-Object LogName, @{label = "MaximumSizeInBytes"; expression = { $_.MaximumSizeInBytes / 1024 } }, LogMode, @{label = "Retention"; expression = { Get-ItemProperty -Path HKLM:\SOFTWARE\Policies\Microsoft\Windows\EventLog\Setup | Select -ExpandProperty Retention } }
    $systemLogResult = Get-WinEvent -ListLog System | Select-Object LogName, @{label = "MaximumSizeInBytes"; expression = { $_.MaximumSizeInBytes / 1024 } }, LogMode, @{label = "Retention"; expression = { Get-ItemProperty -Path HKLM:\SOFTWARE\Policies\Microsoft\Windows\EventLog\System | Select -ExpandProperty Retention } }
    $securityLogResult = Get-WinEvent -ListLog Security | Select-Object LogName, @{label = "MaximumSizeInBytes"; expression = { $_.MaximumSizeInBytes / 1024 } }, LogMode, @{label = "Retention"; expression = { Get-ItemProperty -Path HKLM:\SOFTWARE\Policies\Microsoft\Windows\EventLog\Security | Select -ExpandProperty Retention } }

    $logReport = [ordered]@{
        Application = $applicationLogResult;
        Setup       = $setupLogResult;
        System      = $systemLogResult;
        Security    = $securityLogResult
    }

    return $logReport
}

########################################################################
########################################################################
##                                                                    ##
##                          Examples                                  ## 
##                                                                    ##
########################################################################
########################################################################


#Get-ComputerReport
#Get-QuotaReport

<#
$softwareList = [ordered]@{
    "7-Zip"             = "*Igor Pavlov*" 
    "Adobe"             = "*Adobe*" 
    "Notepad++"         = "*Notepad++ Team*" 
    "Microsoft Edge"    = "*Microsoft*" 
    "Java 8"            = "*Oracle*" 
}
#>
#Get-SoftwareReport -softwareList $softwareList
<#
$user="DOMENA\jnowak"
$groupName="DOMENA\Pracownicy_DP"
$departmentPath="\\SERVER\DP"
Get-FilesReport -userName $user -groupName $groupName -departmentName $departmentPath
#>

#Get-NetworkInformation

#Get-PrintReport

#Get-ServiceReport

#Get-FirewallReport
#New-LogReport
########################################################################

function Prepare-Workplace
{
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$true,HelpMessage="Path",Position=0)]
    [String]$path,
    [Parameter(Mandatory=$true,HelpMessage="GroupName",Position=1)]
    [String]$folder
)

    New-Item –Path $path –Name $folder -ItemType RegistryKey

    "HARDWARE","QUOTA","SOFTWARE","FILESHARE","NETWORK","PRINTER","SERVICE","FIREWALL","LOG" | foreach-Object {
    New-Item –Path "HKLM:\System\TEST" –Name $_ -ItemType RegistryKey
    }
}

#Prepare-Workplace -path "HKLM:\System" -folder TEST


function Save-ToRegistry2Level
{
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$true,HelpMessage="Path",Position=0)]
    [String]$pathToRegistry,
    [Parameter(Mandatory=$true,HelpMessage="DataToSave",Position=1)]
    $hashtableData
)


foreach ($dataElement in $hashtableData.Keys) 
{
    $dataName = $hashtableData[$dataElement]
    $keyPath = Join-Path $pathToRegistry -ChildPath $dataElement
    New-Item -Path $pathToRegistry -Name $dataElement -ItemType RegistryKey
    
    foreach ($property in $dataName.PSObject.Properties) 
    {
        New-ItemProperty -Path $keyPath -Name $property.Name -Value $property.Value -Force
    }
}
}



function Save-ToRegistry1Level
{
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$true,HelpMessage="Path",Position=0)]
    [String]$pathToRegistry,
    [Parameter(Mandatory=$true,HelpMessage="DataToSave",Position=1)]
    $hashtableData
)

    foreach ($element in $lama.Keys)
    {
        New-ItemProperty -Path $pathToRegistry -Name $element -Value $lama[$element] -Force
    }
}
##############################MAIN#######################

#Prepare-Workplace -path "HKLM:\System" -folder TEST



#$lama=Get-ComputerReport
#Save-ToRegistry2Level -pathToRegistry "HKLM:\SYSTEM\TEST\HARDWARE" -hashtableData $lama


#$lama=Get-QuotaReport
#Save-ToRegistry1Level -pathToRegistry "HKLM:\SYSTEM\TEST\QUOTA" -hashtableData $lama


<#
$softwareList = [ordered]@{
    "7-Zip"             = "*Igor Pavlov*" 
    "Adobe"             = "*Adobe*" 
    "Notepad++"         = "*Notepad++ Team*" 
    "Microsoft Edge"    = "*Microsoft*" 
    "Java 8"            = "*Oracle*" 
}

#$lama=Get-SoftwareReport -softwareList $softwareList
#Save-ToRegistry2Level -pathToRegistry "HKLM:\SYSTEM\TEST\SOFTWARE" -hashtableData $lama
#>



#$user="DOMENA\jnowak"
#$groupName="DOMENA\Pracownicy_DP"
#$departmentPath="\\SERVER\DP"

#$lama=Get-FilesReport -userName $user -groupName $groupName -departmentName $departmentPath
#Save-ToRegistry2Level -pathToRegistry "HKLM:\SYSTEM\TEST\FILESHARE" -hashtableData $lama



#$lama=Get-NetworkInformation
#Save-ToRegistry1Level -pathToRegistry "HKLM:\SYSTEM\TEST\NETWORK" -hashtableData $lama


#$lama=Get-PrintReport
#Save-ToRegistry1Level -pathToRegistry "HKLM:\SYSTEM\TEST\PRINTER" -hashtableData $lama


#$lama=Get-ServiceReport
#Save-ToRegistry2Level -pathToRegistry "HKLM:\SYSTEM\TEST\SERVICE" -hashtableData $lama


#$lama=Get-FirewallReport
#Save-ToRegistry2Level -pathToRegistry "HKLM:\SYSTEM\TEST\FIREWALL" -hashtableData $lama


#$lama=New-LogReport
#Save-ToRegistry2Level -pathToRegistry "HKLM:\SYSTEM\TEST\LOG" -hashtableData $lama

###########################

function Get-RegistryLevel1Data
{
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$true,HelpMessage="Path",Position=0)]
    [String]$pathToRegistry
)

$networkReportRegistry=[ordered]@{}

$registryData=Get-ItemProperty -Path $pathToRegistry
$registryData.PSObject.Properties | Where-Object {$_.Name -NotLike "PS*"} | ForEach-Object { $networkReportRegistry.Add($_.Name,$_.Value)}

return $networkReportRegistry

}

Get-RegistryLevel1Data -pathToRegistry "HKLM:\SYSTEM\TEST\NETWORK"

function Get-RegistryLevel2Data
{
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$true,HelpMessage="Path",Position=0)]
    [String]$pathToRegistry
)

    $registryValuesHashtable=[ordered]@{}

    $registryKey=Get-ChildItem -Path $pathToRegistry -Name

    foreach($registryKeyElement in $registryKey)
    {
        $internalPathToRegistry=Join-Path -Path $pathToRegistry -ChildPath $registryKeyElement
        $registryValues=Get-RegistryLevel1Data -pathToRegistry $internalPathToRegistry
        $registryValuesHashtable.Add($registryKeyElement,$registryValues)
    
    }
    return $registryValuesHashtable

}

Get-RegistryLevel2Data -pathToRegistry "HKLM:\SYSTEM\TEST\FILESHARE"





#Define Objects
$filewatcherObject = New-Object System.IO.FileSystemWatcher
$filewatcherObject.Path = "A:\TEST"
$filewatcherObject.Filter = "*.*"
$filewatcherObject.IncludeSubdirectories = $true
$filewatcherObject.EnableRaisingEvents = $true  
 
# Define Actions
$created = { 

                $date=$(Get-Date -UFormat "%d.%m.%Y %T")
                $logline = "[$date] -> Utworzono"
                $filePath ="A:\report.txt"
                Add-Content -Value $logline -Path $filePath
              }
$changed = { 

                $date=$(Get-Date -UFormat "%d.%m.%Y %T")
                $logline = "[$date] -> Zmieniono"
                $filePath ="A:\report.txt"
                Add-Content -Value $logline -Path $filePath
              }
$deleted = { 

                $date=$(Get-Date -UFormat "%d.%m.%Y %T")
                $logline = "[$date] -> Skasowano"
                $filePath ="A:\report.txt"
                Add-Content -Value $logline -Path $filePath
              }
$renamed = { 

                $date=$(Get-Date -UFormat "%d.%m.%Y %T")
                $logline = "[$date] -> Zmiana nazwy"
                $filePath ="A:\report.txt"
                Add-Content -Value $logline -Path $filePath
              }    

 
#Register Events
Register-ObjectEvent $filewatcherObject "Created" -Action $created
Register-ObjectEvent $filewatcherObject "Changed" -Action $changed
Register-ObjectEvent $filewatcherObject "Deleted" -Action $deleted
Register-ObjectEvent $filewatcherObject "Renamed" -Action $renamed
while ($true) {sleep 5}


# To stop the monitoring, run the following commands: 
# Unregister-Event -SourceIdentifier *